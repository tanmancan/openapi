/*
Computer Vision APIs (2024-02-01)

The Computer Vision API provides state-of-the-art algorithms to process images and return information. For example, it can be used to determine if an image contains mature content, or it can be used to find all the people in an image.  It also has other features like categorizing the content of images, and describing an image with complete English sentences.

API version: 2024-02-01
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package azurecv

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiImageAnalysisAnalyzeRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	apiVersion *string
	features *[]string
	modelVersion *string
	language *string
	smartcropsAspectRatios *[]string
	genderNeutralCaption *bool
	body *os.File
}

func (r ApiImageAnalysisAnalyzeRequest) ApiVersion(apiVersion string) ApiImageAnalysisAnalyzeRequest {
	r.apiVersion = &apiVersion
	return r
}

// The visual features requested: tags, objects, caption, denseCaptions, read, smartCrops, people. At least one visual feature must be specified.
func (r ApiImageAnalysisAnalyzeRequest) Features(features []string) ApiImageAnalysisAnalyzeRequest {
	r.features = &features
	return r
}

// Optional parameter to specify the version of the AI model, or \&quot;latest\&quot; to use the latest available model. Defaults to \&quot;latest\&quot;.
func (r ApiImageAnalysisAnalyzeRequest) ModelVersion(modelVersion string) ApiImageAnalysisAnalyzeRequest {
	r.modelVersion = &modelVersion
	return r
}

// The desired language for output generation. If this parameter is not specified, the default value is \&quot;en\&quot;. See https://aka.ms/cv-languages for a list of supported languages.
func (r ApiImageAnalysisAnalyzeRequest) Language(language string) ApiImageAnalysisAnalyzeRequest {
	r.language = &language
	return r
}

// A list of aspect ratios to use for smartCrops feature. Aspect ratios are calculated by dividing the target crop width by the height. Supported values are between 0.75 and 1.8 (inclusive). Multiple values should be comma-separated. If this parameter is not specified, the service will return one crop suggestion with an aspect ratio it sees fit between 0.5 and 2.0 (inclusive).
func (r ApiImageAnalysisAnalyzeRequest) SmartcropsAspectRatios(smartcropsAspectRatios []string) ApiImageAnalysisAnalyzeRequest {
	r.smartcropsAspectRatios = &smartcropsAspectRatios
	return r
}

// Boolean flag for enabling gender-neutral captioning for caption and denseCaptions features. If this parameter is not specified, the default value is \&quot;false\&quot;.
func (r ApiImageAnalysisAnalyzeRequest) GenderNeutralCaption(genderNeutralCaption bool) ApiImageAnalysisAnalyzeRequest {
	r.genderNeutralCaption = &genderNeutralCaption
	return r
}

func (r ApiImageAnalysisAnalyzeRequest) Body(body *os.File) ApiImageAnalysisAnalyzeRequest {
	r.body = body
	return r
}

func (r ApiImageAnalysisAnalyzeRequest) Execute() (*ImageAnalysisResult, *http.Response, error) {
	return r.ApiService.ImageAnalysisAnalyzeExecute(r)
}

/*
ImageAnalysisAnalyze Analyze

Analyze the input image. The request either contains image stream with any content type ['image/*', 'application/octet-stream'], or a JSON payload which includes an url property to be used to retrieve the image stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImageAnalysisAnalyzeRequest
*/
func (a *DefaultAPIService) ImageAnalysisAnalyze(ctx context.Context) ApiImageAnalysisAnalyzeRequest {
	return ApiImageAnalysisAnalyzeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ImageAnalysisResult
func (a *DefaultAPIService) ImageAnalysisAnalyzeExecute(r ApiImageAnalysisAnalyzeRequest) (*ImageAnalysisResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageAnalysisResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ImageAnalysisAnalyze")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/imageanalysis:analyze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api-version", r.apiVersion, "")
	} else {
		var defaultValue string = "2024-02-01"
		r.apiVersion = &defaultValue
	}
	if r.features != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "features", r.features, "csv")
	}
	if r.modelVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model-version", r.modelVersion, "")
	} else {
		var defaultValue string = "latest"
		r.modelVersion = &defaultValue
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "")
	} else {
		var defaultValue string = "en"
		r.language = &defaultValue
	}
	if r.smartcropsAspectRatios != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "smartcrops-aspect-ratios", r.smartcropsAspectRatios, "csv")
	}
	if r.genderNeutralCaption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gender-neutral-caption", r.genderNeutralCaption, "")
	} else {
		var defaultValue bool = false
		r.genderNeutralCaption = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("subscription-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Ocp-Apim-Subscription-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrievalVectorizeImageRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	modelVersion *string
	imageUrl *ImageUrl
}

// Model version. Please refer https://aka.ms/image-retrieval for supported model versions.
func (r ApiRetrievalVectorizeImageRequest) ModelVersion(modelVersion string) ApiRetrievalVectorizeImageRequest {
	r.modelVersion = &modelVersion
	return r
}

// A JSON document with a URL pointing to the image that is to be analyzed.
func (r ApiRetrievalVectorizeImageRequest) ImageUrl(imageUrl ImageUrl) ApiRetrievalVectorizeImageRequest {
	r.imageUrl = &imageUrl
	return r
}

func (r ApiRetrievalVectorizeImageRequest) Execute() (*SingleVectorResult, *http.Response, error) {
	return r.ApiService.RetrievalVectorizeImageExecute(r)
}

/*
RetrievalVectorizeImage VectorizeImage

Return vector from an image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRetrievalVectorizeImageRequest
*/
func (a *DefaultAPIService) RetrievalVectorizeImage(ctx context.Context) ApiRetrievalVectorizeImageRequest {
	return ApiRetrievalVectorizeImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleVectorResult
func (a *DefaultAPIService) RetrievalVectorizeImageExecute(r ApiRetrievalVectorizeImageRequest) (*SingleVectorResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleVectorResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RetrievalVectorizeImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/retrieval:vectorizeImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelVersion == nil {
		return localVarReturnValue, nil, reportError("modelVersion is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "model-version", r.modelVersion, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.imageUrl
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("subscription-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Ocp-Apim-Subscription-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrievalVectorizeTextRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	modelVersion *string
	vectorizeTextRequest *VectorizeTextRequest
}

// Model version. Please refer https://aka.ms/image-retrieval for supported model versions.
func (r ApiRetrievalVectorizeTextRequest) ModelVersion(modelVersion string) ApiRetrievalVectorizeTextRequest {
	r.modelVersion = &modelVersion
	return r
}

// Request of VectorizeText.
func (r ApiRetrievalVectorizeTextRequest) VectorizeTextRequest(vectorizeTextRequest VectorizeTextRequest) ApiRetrievalVectorizeTextRequest {
	r.vectorizeTextRequest = &vectorizeTextRequest
	return r
}

func (r ApiRetrievalVectorizeTextRequest) Execute() (*SingleVectorResult, *http.Response, error) {
	return r.ApiService.RetrievalVectorizeTextExecute(r)
}

/*
RetrievalVectorizeText VectorizeText

Return vector from a text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRetrievalVectorizeTextRequest
*/
func (a *DefaultAPIService) RetrievalVectorizeText(ctx context.Context) ApiRetrievalVectorizeTextRequest {
	return ApiRetrievalVectorizeTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleVectorResult
func (a *DefaultAPIService) RetrievalVectorizeTextExecute(r ApiRetrievalVectorizeTextRequest) (*SingleVectorResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleVectorResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.RetrievalVectorizeText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/retrieval:vectorizeText"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.modelVersion == nil {
		return localVarReturnValue, nil, reportError("modelVersion is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "model-version", r.modelVersion, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vectorizeTextRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("subscription-key", key)
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Ocp-Apim-Subscription-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
